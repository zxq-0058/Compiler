# 实验五

## 建DAG


简单来说，我们的DAG是一个节点数组，原则上每一个节点代表一条指令（当然不完全如此），节点的删除与否可以代表中间指令的删除与否


## 保留节点 NODE_RESERVE


## 叶子节点 NODE_LEAF
**叶子节点是当前块的数值的输入流来源！！！**
首先我们需要知道叶子节点的类别
（1）常数节点 -> 这种节点在导出代码时不需要，但是在建DAG时需要用到
（2）来自上一个块的 v%d -> 这种节点在导出代码时不需要，但是在建DAG时需要用到
（3）来自read的输入 -> 这种节点在导出代码时需要，也在建DAG时需要用到





（任务一）
现在已经做了全局常量传播 -> 找一份随机的代码，通过diff查看是不是真的进行了常量传播
（任务二）
进行死代码的消除

想一想，常量传播中涉及值的流动的地方有哪些？
- 四则运算（不包括ADDRADD，因为这个比较麻烦）
- 赋值语句（我觉得取地址那里最好也判断一下，因为比如说 t = &v, 但是v是一个常数那就坏了）。
- 函数调用
- read，任何read进来的值都是NAC

常量传播做完之后的流动地点：
任何用到了v或者t的地方，只要是常数，就可以直接替换成常数

所以等式左边为*y或者&y的，我觉得都有点麻烦。
TODO: 考虑非NORMAL的赋值语句的潜在风险